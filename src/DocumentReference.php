<?php

namespace Morrislaptop\Firestore;

use Psr\Http\Message\UriInterface;
use Kreait\Firebase\Exception\ApiException;
use Kreait\Firebase\Database\Reference\Validator;
use Kreait\Firebase\Exception\OutOfRangeException;
use Kreait\Firebase\Exception\InvalidArgumentException;

/**
 * A Reference represents a specific location in your database and can be used
 * for reading or writing data to that database location.
 *
 * @see https://firebase.google.com/docs/reference/js/firebase.database.Reference
 */
class DocumentReference
{
    /**
     * @var UriInterface
     */
    private $uri;

    /**
     * @var ApiClient
     */
    private $apiClient;

    /**
     * @var Validator
     */
    private $validator;

    /**
     * @var ValueMapper
     */
    private $valueMapper;

    /**
     * Creates a new Reference instance for the given URI which is accessed by
     * the given API client and validated by the Validator (obviously).
     *
     * @param UriInterface $uri
     * @param ApiClient $apiClient
     * @param Validator|null $validator
     *
     * @throws InvalidArgumentException if the reference URI is invalid
     */
    public function __construct(UriInterface $uri, ApiClient $apiClient, Validator $validator = null, ValueMapper $valueMapper = null)
    {
        $this->validator = $validator ?? new Validator();
        $this->validator->validateUri($uri);

        $this->valueMapper = $valueMapper ?? new ValueMapper(null, false);

        $this->uri = $uri;
        $this->apiClient = $apiClient;
    }

    /**
     * Write data to this database location.
     *
     * This will overwrite any data at this location and all child locations.
     *
     * Passing null for the new value is equivalent to calling {@see remove()}:
     * all data at this location or any child location will be deleted.
     *
     * @param mixed $value
     *
     * @throws ApiException if the API reported an error
     *
     * @return Reference
     */
    public function set($value, $merge = false): self
    {
        $payload = [
            'name' => basename($this->uri->getPath()),
            'fields' => $this->valueMapper->encodeValues($value),
        ];

        if ($merge) {
            $paths = $this->valueMapper->encodeFieldPaths($value);
            $prefix = '&updateMask.fieldPaths=';
            $query = $prefix . implode($prefix, $paths);
            $uri = $this->uri->withQuery("updateMask.fieldPaths=message$query");
        }
        else {
            $uri = $this->uri;
        }

        $this->apiClient->set($uri, $payload);

        return $this;
    }

    /**
     * Returns a data snapshot of the current location.
     *
     * @throws ApiException if the API reported an error
     *
     * @return Snapshot
     */
    public function snapshot(): DocumentSnapshot
    {
        $value = $this->apiClient->get($this->uri);

        $data = $this->valueMapper->decodeValues($value['fields']);

        return new DocumentSnapshot($this, [], $data, true);
    }

    /**
     * Generates a new child location using a unique key and returns its reference.
     *
     * This is the most common pattern for adding data to a collection of items.
     *
     * If you provide a value to push(), the value will be written to the generated location.
     * If you don't pass a value, nothing will be written to the database and the child
     * will remain empty (but you can use the reference elsewhere).
     *
     * The unique key generated by push() are ordered by the current time, so the resulting
     * list of items will be chronologically sorted. The keys are also designed to be
     * unguessable (they contain 72 random bits of entropy).
     *
     * @see https://firebase.google.com/docs/reference/js/firebase.database.Reference#push
     *
     * @param mixed $value
     *
     * @throws ApiException if the API reported an error
     *
     * @return Reference A new reference for the added child
     */
    public function push($value = null): self
    {
        $newKey = $this->apiClient->push($this->uri, $value);
        $newPath = sprintf('%s/%s', $this->uri->getPath(), $newKey);

        /* @noinspection ExceptionsAnnotatingAndHandlingInspection */
        return new self($this->uri->withPath($newPath), $this->apiClient, $this->validator);
    }

    /**
     * Remove the data at this database location.
     *
     * Any data at child locations will also be deleted.
     *
     * @see https://firebase.google.com/docs/reference/js/firebase.database.Reference#remove
     *
     * @throws ApiException if the API reported an error
     *
     * @return Reference A new instance for the now empty Reference
     */
    public function remove(): self
    {
        $this->apiClient->remove($this->uri);

        return $this;
    }

    /**
     * Writes multiple values to the database at once.
     *
     * The values argument contains multiple property/value pairs that will be written to the database together.
     * Each child property can either be a simple property (for example, "name"), or a relative path
     * (for example, "name/first") from the current location to the data to update.
     *
     * As opposed to the {@see set()} method, update() can be use to selectively update only the referenced properties
     * at the current location (instead of replacing all the child properties at the current location).
     *
     * Passing null to {see update()} will remove the data at this location.
     *
     * @see https://firebase.google.com/docs/reference/js/firebase.database.Reference#update
     *
     * @param array $values
     *
     * @throws ApiException if the API reported an error
     *
     * @return Reference
     */
    public function update(array $values): self
    {
        $this->apiClient->update($this->uri, $values);

        return $this;
    }

    /**
     * Returns the absolute URL for this location.
     *
     * This method returns a URL that is ready to be put into a browser, curl command, or a
     * {@see Database::getReferenceFromUrl()} call. Since all of those expect the URL
     * to be url-encoded, toString() returns an encoded URL.
     *
     * Append '.json' to the URL when typed into a browser to download JSON formatted data.
     * If the location is secured (not publicly readable),
     * you will get a permission-denied error.
     *
     * @see https://firebase.google.com/docs/reference/js/firebase.database.Reference#toString
     *
     * @return UriInterface
     */
    public function getUri(): UriInterface
    {
        return $this->uri;
    }

    /**
     * Returns the absolute URL for this location.
     *
     * @see getUri()
     *
     * @return string
     */
    public function __toString()
    {
        return (string) $this->getUri();
    }

    /**
     * Returns a new query for the current reference.
     *
     * @return Query
     */
    private function query(): Query
    {
        return new Query($this, $this->apiClient);
    }
}
